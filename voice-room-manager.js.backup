/**
 * VoiceRoomManager - 语音聊天室管理器（使用 PeerJS）
 * 负责协调多个 WebRTC 连接（mesh topology）
 * 通过 EventBus 发送事件，完全独立于 UI
 * 使用 PeerJS 进行信令，避免通过聊天消息传输大量数据
 */
class VoiceRoomManager {
  /**
   * 创建语音聊天室管理器
   * @param {EventBus} eventBus - 事件总线
   * @param {WebSocketManager} wsManager - WebSocket 管理器（用于广播状态）
   */
  constructor(eventBus, wsManager, config = {}) {
    this.eventBus = eventBus;
    this.wsManager = wsManager;

    // Voice chat state
    this.inVoice = false;
    this.localStream = null;
    this.isMuted = false;
    this.username = null;
    this.roomname = null;
    this.voiceJoinTimestamp = null;

    // PeerJS instance
    this.peer = null;
    this.peerId = null;

    // Peer connections map: username -> { call, stream }
    this.peers = new Map();

    // Remote streams map: username -> MediaStream
    this.remoteStreams = new Map();

    // Username to PeerID mapping
    this.usernameToPeerId = new Map();

    // Subscribe to WebSocket messages for peer ID exchange
    this.setupSignalingHandlers();
  }

  /**
   * 设置 WebSocket 信令处理器
   * 通过 EventBus 监听聊天消息，用于交换 PeerJS ID
   */
  setupSignalingHandlers() {
    // 监听聊天消息事件，检查是否为 PeerID 交换消息
    this.eventBus.on('message:received', (data) => {
      this.handleChatMessage(data);
    });
  }

  /**
   * 加入语音聊天
   * @param {string} username - 用户名
   * @param {string} roomname - 房间名
   */
  async joinVoiceChat(username, roomname) {
    if (this.inVoice) {
      console.warn('Already in voice chat');
      return;
    }

    if (!username || !roomname) {
      throw new Error('Username and roomname required');
    }

    this.username = username;
    this.roomname = roomname;
    this.voiceJoinTimestamp = Date.now();

    try {
      // Request microphone access
      this.localStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        },
        video: false
      });

      // Initialize PeerJS
      await this.initializePeer();

      this.inVoice = true;

      // Broadcast voice state with PeerID
      this.broadcastVoiceState();

      // Emit event
      this.eventBus.emit('voice:joined', {
        username: this.username,
        local: true
      });

      console.log('Joined voice chat with PeerID:', this.peerId);
    } catch (error) {
      console.error('Failed to join voice chat:', error);
      this.eventBus.emit('voice:error', {
        message: 'Failed to join voice chat',
        error
      });
      throw error;
    }
  }

  /**
   * 初始化 PeerJS
   */
  async initializePeer() {
    return new Promise((resolve, reject) => {
      // Create a unique peer ID based on username and timestamp
      const peerId = `${this.roomname}-${this.username}-${Date.now()}`.replace(/[^a-zA-Z0-9-]/g, '_');

      this.peer = new Peer(peerId, {
        debug: 0 // Set to 2 for verbose logging
      });

      this.peer.on('open', (id) => {
        this.peerId = id;
        console.log('PeerJS connected with ID:', id);

        // Handle incoming calls
        this.peer.on('call', (call) => {
          console.log('Receiving call from:', call.peer);
          // Answer the call with our local stream
          call.answer(this.localStream);
          this.handleIncomingCall(call);
        });

        resolve();
      });

      this.peer.on('error', (error) => {
        console.error('PeerJS error:', error);
        reject(error);
      });

      this.peer.on('disconnected', () => {
        console.log('PeerJS disconnected');
      });

      this.peer.on('close', () => {
        console.log('PeerJS connection closed');
      });
    });
  }

  /**
   * 离开语音聊天
   */
  leaveVoiceChat() {
    if (!this.inVoice) return;

    // Stop local stream
    if (this.localStream) {
      this.localStream.getTracks().forEach(track => track.stop());
      this.localStream = null;
    }

    // Close all peer connections
    this.peers.forEach((manager) => {
      manager.close();
    });
    this.peers.clear();
    this.remoteStreams.clear();

    this.inVoice = false;
    this.voiceJoinTimestamp = null;

    // Notify server
    this.broadcastVoiceState();

    // Emit event
    this.eventBus.emit('voice:left', {
      username: this.username,
      local: true
    });

    console.log('Left voice chat');
  }

  /**
   * 切换麦克风静音状态
   * @returns {boolean} 新的静音状态
   */
  toggleMute() {
    if (!this.inVoice || !this.localStream) {
      console.warn('Not in voice chat');
      return this.isMuted;
    }

    this.isMuted = !this.isMuted;

    // Mute/unmute audio tracks
    this.localStream.getAudioTracks().forEach(track => {
      track.enabled = !this.isMuted;
    });

    // Notify others
    this.broadcastVoiceState();

    // Emit event
    this.eventBus.emit('voice:muted', {
      username: this.username,
      muted: this.isMuted
    });

    console.log(`Microphone ${this.isMuted ? 'muted' : 'unmuted'}`);
    return this.isMuted;
  }

  /**
   * 广播语音状态到其他用户（使用纯文本消息格式）
   */
  broadcastVoiceState() {
    this.sendVoiceState();
  }

  /**
   * 发送语音状态（可定向）
   * @param {string|null} to - 目标用户名，null 表示广播
   */
  sendVoiceState(to = null) {
    const payload = { inVoice: this.inVoice, muted: this.isMuted };
    const type = 'state';

    if (!this.wsManager.isConnected()) return;

    void this.sendVoicePayload(type, to, payload);
  }

  /**
   * 发送信令消息（使用纯文本消息格式）
   * @param {Object} data - 信令数据
   */
  sendSignaling(data) {
    if (!this.wsManager.isConnected()) {
      console.warn('WebSocket not connected, cannot send signaling');
      return;
    }

    // 使用特殊前缀的纯文本消息格式: [VOICE:type:to:payload]
    const to = data.to || 'all';
    void this.sendVoicePayload(data.type, to, data);
  }

  async sendVoicePayload(type, to, payload) {
    try {
      const encoded = await this.encodeVoicePayload(payload);
      const maxMessageLen = 160; // Server limit
      const directMessage = to
        ? `[VOICE:${type}:${to}:${encoded}]`
        : `[VOICE:${type}:${encoded}]`;

      if (directMessage.length <= maxMessageLen) {
        this.wsManager.send({ message: directMessage });
        return;
      }

      this.sendChunkedPayload(type, to, encoded, maxMessageLen);
    } catch (e) {
      console.error('Failed to encode signaling payload:', e);
    }
  }

  sendChunkedPayload(type, to, encoded, maxMessageLen) {
    const chunkId = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
    const emptyChunkPayload = JSON.stringify({
      id: chunkId,
      type,
      index: 0,
      total: 0,
      chunk: ''
    });
    const chunkPrefix = `[VOICE:chunk:${to || 'all'}:`;
    const maxChunkLen = Math.max(1, maxMessageLen - chunkPrefix.length - emptyChunkPayload.length - 1);
    const chunks = [];
    for (let i = 0; i < encoded.length; i += maxChunkLen) {
      chunks.push(encoded.slice(i, i + maxChunkLen));
    }

    const total = chunks.length;
    chunks.forEach((chunk, index) => {
      const payload = JSON.stringify({
        id: chunkId,
        type,
        index,
        total,
        chunk
      });
      const message = `[VOICE:chunk:${to || 'all'}:${payload}]`;
      setTimeout(() => {
        this.wsManager.send({ message });
      }, index * 3000); // 3 seconds delay to avoid rate limiting
    });
  }

  /**
   * 解析收到的语音消息
   * @param {string} message - 消息文本
   * @returns {Object|null} 解析后的数据
   */
  parseVoiceMessage(message) {
    // 匹配格式: [VOICE:type:target:data] 或 [VOICE:type:data]
    if (!message.startsWith('[VOICE:') || !message.endsWith(']')) return null;

    const payload = message.slice('[VOICE:'.length, -1);
    const firstColon = payload.indexOf(':');
    if (firstColon === -1) return null;

    const type = payload.slice(0, firstColon);
    const rest = payload.slice(firstColon + 1);

    if (rest.startsWith('{') || rest.startsWith('gz.') || rest.startsWith('df.') || rest.startsWith('raw.')) {
      // 格式: [VOICE:type:data]
      return {
        type,
        to: null,
        data: rest
      };
    }

    const secondColon = rest.indexOf(':');
    if (secondColon === -1) return null;
    const to = rest.slice(0, secondColon);
    const data = rest.slice(secondColon + 1);

    // 格式: [VOICE:type:to:data]
    return {
      type,
      to,
      data
    };
  }

  /**
   * 处理收到的聊天消息，检查是否为语音信令
   * @param {Object} messageData - 消息数据 { name, message, timestamp }
   */
  async handleChatMessage(messageData) {
    const { name, message } = messageData;
    if (this.shouldIgnoreStaleVoiceMessage(messageData)) return;
    await this.handleVoiceMessage(name, message);
  }

  handleSignalingMessage(raw) {
    let payload = null;
    if (typeof raw === 'string' && raw.trim().startsWith('{')) {
      try {
        payload = JSON.parse(raw);
      } catch (e) {
        console.warn('Failed to parse signaling payload:', e);
      }
    }

    if (payload && payload.message) {
      this.handleVoiceMessage(payload.from, payload.message);
      return;
    }

    // Fallback: treat raw as a voice message without sender
    this.handleVoiceMessage(null, raw);
  }

  async handleVoiceMessage(name, message) {
    try {
      if (!name || name === this.username) return;
      if (!message || !message.startsWith('[VOICE:')) return;

      const parsed = this.parseVoiceMessage(message);
      if (!parsed) return;

      const { type, to, data } = parsed;
      if (to && to !== 'all' && to !== this.username) return;

      const decoded = await this.decodeVoicePayload(data);

      if (type === 'chunk') {
        await this.handleChunkedSignaling(name, decoded);
        return;
      }

      this.handleDecodedSignaling(type, name, decoded);
    } catch (e) {
      console.warn('Failed to decode voice payload:', e);
    }
  }

  handleDecodedSignaling(type, name, decoded) {
    console.log(`[Voice] Received ${type} from ${name}:`, decoded);
    switch (type) {
      case 'state':
        this.handleVoiceState({ username: name, ...decoded });
        break;
      case 'webrtc-offer':
        if (this.inVoice) {
          this.handleOffer(name, decoded.offer);
        }
        break;
      case 'webrtc-answer':
        this.handleAnswer(name, decoded.answer);
        break;
      case 'webrtc-ice-candidate':
        this.handleIceCandidate(name, decoded.candidate);
        break;
    }
  }

  async handleChunkedSignaling(from, data) {
    const { id, type, index, total, chunk } = data || {};
    if (!id || !type || typeof index !== 'number' || typeof total !== 'number' || typeof chunk !== 'string') {
      console.warn('Invalid chunked signaling data:', data);
      return;
    }

    const key = `${from}:${id}`;
    let buffer = this.chunkBuffer.get(key);
    if (!buffer) {
      buffer = { type, total, chunks: new Array(total) };
      this.chunkBuffer.set(key, buffer);
    }

    if (buffer.total !== total) {
      console.warn('Chunk total mismatch:', buffer.total, total);
      return;
    }

    buffer.chunks[index] = chunk;

    if (buffer.chunks.every(c => typeof c === 'string')) {
      this.chunkBuffer.delete(key);
      const full = buffer.chunks.join('');
      try {
        const decoded = await this.decodeVoicePayload(full);
        this.handleDecodedSignaling(buffer.type, from, decoded);
      } catch (e) {
        console.error('Failed to parse reconstructed signaling:', e);
      }
    }
  }

  shouldIgnoreStaleVoiceMessage(messageData) {
    if (!this.voiceJoinTimestamp) return false;
    if (!messageData || typeof messageData.timestamp === 'undefined') return false;
    const ts = this.normalizeTimestamp(messageData.timestamp);
    if (ts === null) return false;
    return ts < this.voiceJoinTimestamp;
  }

  normalizeTimestamp(value) {
    const num = Number(value);
    if (!Number.isFinite(num) || num <= 0) return null;
    return num < 1e12 ? num * 1000 : num;
  }

  async encodeVoicePayload(payload) {
    const json = JSON.stringify(payload);
    return this.compressToBase64(json);
  }

  async decodeVoicePayload(raw) {
    if (typeof raw !== 'string') return raw;
    if (raw.startsWith('{') || raw.startsWith('[')) {
      return JSON.parse(raw);
    }
    if (raw.startsWith('"')) {
      const parsed = JSON.parse(raw);
      if (typeof parsed === 'string') {
        return parsed.startsWith('{') || parsed.startsWith('[')
          ? JSON.parse(parsed)
          : parsed;
      }
      return parsed;
    }
    if (raw.startsWith('gz.') || raw.startsWith('df.') || raw.startsWith('raw.')) {
      return this.tryDecodeCompressed(raw);
    }
    if (this.looksLikeBase64(raw)) {
      const text = this.decodeUtf8(this.bytesFromBase64(raw));
      return JSON.parse(text);
    }
    throw new Error('Unknown voice payload format');
  }

  async tryDecodeCompressed(raw) {
    try {
      const text = await this.decompressFromBase64(raw);
      return JSON.parse(text);
    } catch (e) {
      const altPrefix = raw.startsWith('gz.') ? 'df.' : raw.startsWith('df.') ? 'gz.' : null;
      if (altPrefix) {
        try {
          const altText = await this.decompressFromBase64(altPrefix + raw.slice(4));
          return JSON.parse(altText);
        } catch (altError) {
          // continue to raw fallback
        }
      }
      try {
        const text = this.decodeUtf8(this.bytesFromBase64(raw.slice(4)));
        return JSON.parse(text);
      } catch (rawError) {
        throw e;
      }
    }
  }

  async compressToBase64(text) {
    const encoder = new TextEncoder();
    const input = encoder.encode(text);

    if (typeof CompressionStream !== 'undefined') {
      try {
        const compressed = await this.compressBytes(input, 'gzip');
        return `gz.${this.base64FromBytes(compressed)}`;
      } catch (e) {
        // continue to deflate
      }
      try {
        const compressed = await this.compressBytes(input, 'deflate');
        return `df.${this.base64FromBytes(compressed)}`;
      } catch (e) {
        // fall through to raw
      }
    }

    return `raw.${this.base64FromBytes(input)}`;
  }

  async decompressFromBase64(payload) {
    // Check for prefix format: "gz.", "df.", or "raw."
    let type, encoded;
    if (payload.startsWith('gz.')) {
      type = 'gzip';
      encoded = payload.slice(3); // Remove "gz."
    } else if (payload.startsWith('df.')) {
      type = 'deflate';
      encoded = payload.slice(3); // Remove "df."
    } else if (payload.startsWith('raw.')) {
      encoded = payload.slice(4); // Remove "raw."
      return this.decodeUtf8(this.bytesFromBase64(encoded));
    } else {
      throw new Error('Unknown compression format');
    }

    if (typeof DecompressionStream === 'undefined') {
      throw new Error('DecompressionStream not supported');
    }

    const bytes = this.bytesFromBase64(encoded);
    const decompressed = await this.decompressBytes(bytes, type);
    return this.decodeUtf8(decompressed);
  }

  async compressBytes(bytes, type) {
    const stream = new CompressionStream(type);
    const writer = stream.writable.getWriter();
    const reader = stream.readable.getReader();
    const chunks = [];

    writer.write(bytes);
    writer.close();

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
    }

    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      result.set(chunk, offset);
      offset += chunk.length;
    }

    return result;
  }

  async decompressBytes(bytes, type) {
    try {
      const stream = new DecompressionStream(type);
      const writer = stream.writable.getWriter();
      const reader = stream.readable.getReader();
      const chunks = [];

      writer.write(bytes);
      writer.close();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
      }

      const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }

      return result;
    } catch (e) {
      throw new Error(`Failed to decompress (${type}): ${e?.message || e}`);
    }
  }

  base64FromBytes(bytes) {
    let binary = '';
    const chunkSize = 0x8000;
    for (let i = 0; i < bytes.length; i += chunkSize) {
      const chunk = bytes.subarray(i, i + chunkSize);
      binary += String.fromCharCode(...chunk);
    }
    return btoa(binary);
  }

  bytesFromBase64(base64) {
    let normalized = base64.replace(/-/g, '+').replace(/_/g, '/');
    const pad = normalized.length % 4;
    if (pad) normalized += '='.repeat(4 - pad);
    if (/[^A-Za-z0-9+/=]/.test(normalized)) {
      throw new Error('Invalid base64 payload');
    }
    const binary = atob(normalized);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }

  looksLikeBase64(value) {
    if (value.length < 8) return false;
    return /^[A-Za-z0-9+/=_-]+$/.test(value);
  }

  decodeUtf8(bytes) {
    const decoder = new TextDecoder();
    return decoder.decode(bytes);
  }

  /**
   * 处理语音状态消息
   * @param {Object} data - 语音状态数据
   */
  handleVoiceState(data) {
    const { username, inVoice, muted } = data;

    if (username === this.username) return; // Ignore own state
    const hadPeer = this.peers.has(username);

    if (inVoice) {
      // Remote user joined voice
      this.eventBus.emit('voice:joined', {
        username,
        local: false
      });

      // If we're also in voice, initiate connection
      if (this.inVoice) {
        if (!hadPeer) {
          this.createPeerConnection(username);
          // If the remote joined after us, tell them our current state
          this.sendVoiceState(username);
        }
      }
    } else {
      // Remote user left voice
      this.removePeer(username);
      this.eventBus.emit('voice:left', {
        username,
        local: false
      });
    }

    if (muted !== undefined) {
      this.eventBus.emit('voice:muted', {
        username,
        muted
      });
    }
  }

  /**
   * 创建与远程用户的对等连接
   * @param {string} remoteUsername - 远程用户名
   */
  async createPeerConnection(remoteUsername) {
    if (this.peers.has(remoteUsername)) {
      console.warn(`Peer connection to ${remoteUsername} already exists`);
      return;
    }

    console.log(`Creating peer connection to ${remoteUsername}`);

    const manager = new WebRTCManager({
      trickleIce: false,
      maxCandidates: 2, // Reduced from 4 to minimize SDP size
      onIceCandidate: (candidate) => {
        this.sendSignaling({
          type: 'webrtc-ice-candidate',
          to: remoteUsername,
          candidate
        });
      },
      onRemoteStream: (stream) => {
        console.log(`Received remote stream from ${remoteUsername}`);
        this.remoteStreams.set(remoteUsername, stream);
        this.eventBus.emit('voice:stream-added', {
          username: remoteUsername,
          stream
        });
      },
      onConnectionStateChange: (state) => {
        console.log(`Connection to ${remoteUsername}: ${state}`);
        this.eventBus.emit('voice:connection-state', {
          username: remoteUsername,
          state
        });

        if (state === 'failed' || state === 'closed') {
          this.removePeer(remoteUsername);
        }
      }
    });

    this.peers.set(remoteUsername, manager);

    // Add local stream
    if (this.localStream) {
      manager.addLocalStream(this.localStream);
    }

    // Create and send offer
    try {
      const offer = await manager.createOffer();
      this.sendSignaling({
        type: 'webrtc-offer',
        to: remoteUsername,
        offer
      });
    } catch (error) {
      console.error('Failed to create offer:', error);
      this.removePeer(remoteUsername);
    }
  }

  /**
   * 移除对等连接
   * @param {string} username - 用户名
   */
  removePeer(username) {
    const manager = this.peers.get(username);
    if (manager) {
      manager.close();
      this.peers.delete(username);
    }

    const stream = this.remoteStreams.get(username);
    if (stream) {
      this.remoteStreams.delete(username);
      this.eventBus.emit('voice:stream-removed', {
        username
      });
    }
  }

  /**
   * 处理信令消息
   * @param {Object} data - 信令数据
   */
  async handleSignaling(data) {
    const { type, from, offer, answer, candidate } = data;

    if (from === this.username) return; // Ignore own messages

    switch (type) {
      case 'webrtc-offer':
        await this.handleOffer(from, offer);
        break;

      case 'webrtc-answer':
        await this.handleAnswer(from, answer);
        break;

      case 'webrtc-ice-candidate':
        await this.handleIceCandidate(from, candidate);
        break;
    }
  }

  /**
   * 处理 WebRTC offer
   * @param {string} from - 发送者用户名
   * @param {RTCSessionDescriptionInit} offer - SDP offer
   */
  async handleOffer(from, offer) {
    console.log(`Received offer from ${from}`);

    // Create peer connection if doesn't exist
    if (!this.peers.has(from)) {
      const manager = new WebRTCManager({
        trickleIce: false,
        maxCandidates: 4,
        onIceCandidate: (candidate) => {
          this.sendSignaling({
            type: 'webrtc-ice-candidate',
            to: from,
            candidate
          });
        },
        onRemoteStream: (stream) => {
          console.log(`Received remote stream from ${from}`);
          this.remoteStreams.set(from, stream);
          this.eventBus.emit('voice:stream-added', {
            username: from,
            stream
          });
        },
        onConnectionStateChange: (state) => {
          console.log(`Connection to ${from}: ${state}`);
          this.eventBus.emit('voice:connection-state', {
            username: from,
            state
          });

          if (state === 'failed' || state === 'closed') {
            this.removePeer(from);
          }
        }
      });

      this.peers.set(from, manager);

      // Add local stream
      if (this.localStream) {
        manager.addLocalStream(this.localStream);
      }
    }

    const manager = this.peers.get(from);

    try {
      await manager.handleOffer(offer);
      const answer = await manager.createAnswer();

      this.sendSignaling({
        type: 'webrtc-answer',
        to: from,
        answer
      });
    } catch (error) {
      console.error('Failed to handle offer:', error);
      this.removePeer(from);
    }
  }

  /**
   * 处理 WebRTC answer
   * @param {string} from - 发送者用户名
   * @param {RTCSessionDescriptionInit} answer - SDP answer
   */
  async handleAnswer(from, answer) {
    console.log(`Received answer from ${from}`);

    const manager = this.peers.get(from);
    if (!manager) {
      console.warn(`No peer connection for ${from}`);
      return;
    }

    try {
      await manager.handleAnswer(answer);
    } catch (error) {
      console.error('Failed to handle answer:', error);
      this.removePeer(from);
    }
  }

  /**
   * 处理 ICE candidate
   * @param {string} from - 发送者用户名
   * @param {RTCIceCandidateInit} candidate - ICE candidate
   */
  async handleIceCandidate(from, candidate) {
    const manager = this.peers.get(from);
    if (!manager) {
      console.warn(`No peer connection for ${from}`);
      return;
    }

    try {
      await manager.addIceCandidate(candidate);
    } catch (error) {
      console.error('Failed to add ICE candidate:', error);
    }
  }

  /**
   * 获取所有语音参与者
   * @returns {string[]} 参与者用户名列表
   */
  getParticipants() {
    const participants = Array.from(this.peers.keys());
    if (this.inVoice) {
      participants.unshift(this.username);
    }
    return participants;
  }

  /**
   * 获取远程音频流
   * @param {string} username - 用户名
   * @returns {MediaStream|null} 音频流
   */
  getRemoteStream(username) {
    return this.remoteStreams.get(username) || null;
  }

  /**
   * 销毁管理器
   */
  destroy() {
    this.leaveVoiceChat();
  }
}
